---
title:  "클린코드"
excerpt : 클린코드 내용 정리
categories:
  - 코딩 도서
tags:
  - 코딩 도서
  - 개발
toc: true
toc_sticky: true
---
클린 코드 내용 정리

# 1. 깨끗한 코드

- 좋은 코드는 중요하다

- 르블랑의 법칙: 나중은 결코 오지 않는다.

- 나쁜 코드가 쌓일수록 팀 생산성은 떨어진다. 그러다 마침내 0에 근접한다.

- 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가답지 못하다. 
(급한 환자의 말을 듣고 수술전에 손을 씻지 않는 의사와 같다.)

- 빨리 가는 유일한 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.

- 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 안다는 것은 아니다.

## 1.1 깨끗한 코드란?  

- cpu 자원을 낭비하지 않는 코드
- 세세한 사항까지 꼼꼼하게 처리하는 코드
- 가독성이 좋고 명쾌해야 한다.
- 다른 사람이 고치기 쉬워야 한다.
- 주의를 기울인 코드
- 중복을 피해야 한다.
- 한 기능만 수행해야 한다.
- 작게 추상화한다.
- 읽으면서 짐작한 대로 돌아가야 한다.

- 코드를 읽는 시간 대 코드를 짜는 시간 비율이 10대 1을 넘는 경우도 있다. 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다.

- 체크아웃할 때보다 좀 더 깨끗한 코드를 체크인한다면 코드는 절대 나빠지지 않는다.


# 2. 의미있는 이름

## 2.1. 이름을 잘 짓는 간단한 규칙

- 의도를 분명히 밝혀라, 이름은 존재 이유/수행 기능/사용 방법을 분명히 나타내야 한다.
```
if (cell[STATUS_VALUE] == FLAGGED)
```
보다 아래 코드가 좋다.
```
if (cell.isFlagged())
```

- 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용하면 안 된다.
- 실제 List 자료구조를 사용하지 않는다면 변수명을 accountList라 명명하면 안된다.
- 서로 흡사한 이름을 사용하지 않는다.
- 소문자 L과 대문자 O 사용에 주의한다.

- 변수명을 의미있게 구분해라. arr - brr, a1 - a2 ... aN 은 부적절하다. 읽는 사람이 차이를 알아야 한다.

- 발음하기 쉬운 이름을 사용해라.

- 검색하기 쉬운 이름을 사용해라. 문자 하나를 사용하는 이름은 검색이 어렵다.
- 이름 길이는 범위 크기에 비례해야 한다. 여러 곳에서 사용하는 변수는 검색하기 쉬운 이름이 바람직하다.

- 이름에 인코딩을 피해라.
- 인터페이스 클래스와 구현 클래스 중에선 구현 클래스 이름을 인코딩 하는 것이 좋다. C[...] or [...]Imp

- 루프에서 반복 횟수를 세는 변수 i, j, k는 괜찮다. 단, 루프 범위가 아주 작고 다른 이름과 충돌하지 않을 때만

- 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.
- 메서드 이름은 동사나 동사구가 적합하다.
- 접근자-get 변경자-set 조건자-is 표준에 따른 메서드 접두사를 사용한다.
- 생성자를 중복정의 할 때는 [정적 팩토리 메서드](https://velog.io/@ljinsk3/%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C)를 사용한다.
```
Complex fulcrumPoint = new Complex(23.0);
```
보다 아래 코드가 좋다.
```
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
```

- 추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다. 예를 들어, 똑같은 메서드를 클래스마다 fetch, retrieve, get으로 제각각 부르면 혼란스럽다. (controller-manager-driver도 마찬가지)

- 한 단어를 두 가지 목적으로 사용하지 마라. 예를 들어, 값을 더해 새로운 값을 만드는 add 메서드와 집합에 값 하나를 추가하는 insert/append 는 구별해야 한다.

- 프로그래밍 용어를 사용하되, 적절한 용어가 없다면 문제 영역에서 이름을 가져와라.

- 클래스, 함수, 이름 공간에 넣어 의미있는 맥락을 부여해라. 모든 방법이 실패하면 마지막으로 접두어를 붙여라.

- 의미가 분명하다면 불필요한 맥락을 없애라. 일반적으론 짧은 이름이 긴 이름보다 좋다. 

# 3. 함수


- 함수를 만드는 첫째 규칙은 '작게!'다. 둘째 규칙은 '더 작게!'다.

- if/else/while 문 안에 들어가는 블록은 한 줄이어야 한다.

- 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

- 함수는 한 가지를 해야 한다. 한 가지만 해야 한다.

- 지정된 함수 이름 아래서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.

- 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.

- 한 함수 내에 추상화 수준을 섞으면 표현이 근본 개념인지 세부사항인지 구분하기 어려워진다.

- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 즉 한 함수 다음엔 추상화 수준이 한 단계 낮은 함수가 오는 것이 좋다: 내려가기 규칙

- 객체지향 5원칙

- switch 문은 다형성 객체를 생성하는 코드(예를 들어 추상 팩토리)에서만 쓰는 것이 좋다.

- 길고 서술적인 함수 이름이 짧고 어려운 이름보다 좋다.

- 함수에서 이상적인 인수 개수는 0이고, 3개 이상은 가급적 피하는 것이 좋다.

- 함수에 인수 1개를 넘기는 이유는 보통 2가지이다. 하나는 인수에 질문을 던지는 경우, 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우이다. 이외에 이벤트 등이 있다.

- 변환 함수에서 전달한 인수의 상태를 바꿔주는 것(출력 인수라고 한다.)보다 변환 결과를 반환값으로 돌려주는 것이 좋다. 
  또는 report.appendFooter() 처럼 자기 자신의 상태를 바꾸는 식으로 해라. 출력인수는 쓰지 마라.

- 플래그인수는 쓰지 마라. 차라리 함수를 두개로 나눠라.

- 어떤 코드든 절대로 무시하지 마라. 무시한 코드에 오류가 숨어든다.

- 이항함수는 읽기 어렵기 때문에 가능하면 단항함수로 바꾸도록 해야 한다. 예를 들어, 
  writeField(outputStream, name) -> outputStream.writeField(name)
  
- 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.
Circle makeCircle(double x, double y) -> Circle makeCircle(Point center)

- 단항 함수의 좋은 이름은 함수와 인수가 동사/명사 쌍을 이뤄야 한다. write(name), writeField(name)

- 함수 이름에 인수 이름을 넣는 것도 좋다.

- 부수 효과를 일으키지 마라.(함수에서 두가지 일을 하지 마라) 많은 경우 시간적인 결합이나 순서 종속성을 초래한다.

- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나다.

- 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 규칙을 위반한다. 예외를 사용하는 것이 낫다.

- 오류 처리도 한가지 작업이다. 오류를 처리하는 함수는 오류만 처리해야 마땅하다. try/catch 블럭은 다른 함수의 일부가 되기 보다는 따로 이것만 있는 함수만 뽑는 것이 낫다.

- 여러 함수에서 반복되는 부분을 중복해서 사용하지 마라.

- 함수가 작을 때는 return break continue를 여러 차례 사용해도 괜찮다. 하지만 함수가 클 때는 break나 continue 를 사용하지 않고 return을 하나만 사용하는 것이 좋다.

- 처음 함수를 짤 때는 길고 복잡하다. 하지만 이 코드를 테스트하는 단위 테스트 케이스를 만들어야 한다. 이후엔 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 코드는 항상 단위 테스트를 통과한다. 최종적으로 이 장에서 설명한 규칙을 따르는 함수가 만들어진다.

# 4. 주석

- 주석은 언제나 실패를 의미한다. 주석이 필요한 상황이 생기면, 상황을 역전해 코드로 의도를 표현할 방법은 없을까? 생각해야 한다.

- 주석은 오래될수록 코드와 멀어진다. 오래될수록 완전히 그릇될수도 있다. 프로그래머들이 주석을 유지하고 보수하기란 현실적으로 불가능하기 때문이다.

- 프로그래머들이 주석을 엄격하게 관리하는 것도 한가지 해결책일 수 있지만, 애초에 주석이 필요 없는 방향으로 에너지를 쏟는 것이 좋다.

- 부정확한 주석은 아예 없는 것보다 훨씬 더 나쁘다.

- 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨씬 좋다.

- 코드만으로 의도를 설명하기 어려운 경우가 존재하긴 하지만, 몇 초만 더 생각하면 코드로 대다수 의도를 표현할 수 있다.

## 좋은 주석

- 법적인 주석: 저작권 정보와 소유권 정보는 필요하고 타당하다.

- 결과를 경고하는 주석

- TODO주석: 앞으로 할 일

- 중요성을 강조하는 주석

- 공개 API에서 javadocs

- 정보를 제공하거나, 코드 의도를 설명하거나, 의미를 명료하게 밝히는 주석(단, 보통 코드로 대체 가능)

## 나쁜 주석

- 주절거리는 주석(뭐라는지 모르겠는 주석)

- 같은 이야기를 반복하는 주석

- 오해할 여지가 있는 주석

- 의무적으로 다는 주석

- 이력을 기록하는 주석

- 있으나 마나 한 주석

- 함수나 변수로 표현할 수 있는 주석

- 닫는 괄호에 다는 주석( }//try, }//while 등) : 대신에 함수를 줄여라

- 공로를 돌리거나 저자를 표시하는 주석: git으로 해라.

- 주석으로 처리한 코드: git이 있으니 차라리 코드를 삭제해라.

- HTML 주석

- 함수 헤더

- 비공개 코드에서 Javadocs

- 주석을 달아야 한다면 근처에 있는 코드만 기술해라. 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라.

- 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다.

- 주석에 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라.

# 5. 형식 맞추기

- 형식을 깔끔하게 맞춰 코드를 짜야 한다. 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다. 단 맹목적으로 따라선 안된다.

- 전문 개발자의 일차적인 의무는 돌아가는 코드가 아니라 가독성이 좋고 의사소통이 원활한 코드를 짜는 것이다.

- 적절한 행 길이를 유지해라. 대부분 200줄 정도의 파일로도 커다란 시스템을 구축할 수 있다.

- 신문기사처럼 작성해라. 첫 문단은 전체 기사 내용을 요약하고 커다란 그림을 보여준다. (고차원 개념과 알고리즘을 설명한다.) 쭉 읽으며 내려가면 세세한 사실이 조금씩 드러난다. 특히 이름을 신경써서 짓는다.

- 개념은 빈 행으로 분리해라. 일련의 행 묶음은 완결된 생각 하나를 표현한다. 생각 사이는 빈 행을 넣어 분리해야 마땅하다. 예를 들어, 패키지 선언부, import문, 각 함수 사이에 빈 행이 들어간다.

- 세로 밀집도는 연관성을 의미한다. 서로 밀집한 코드 행은 세로로 가까이 놓아야 한다.

- 서로 밀접한 개념은 한 파일에 속해야 마땅하다. protected 변수(동일 패키지 내의 클래스이거나 해당 클래스를 상속 받으면 접근 가능한 멤버 변수) 를 피해야 하는 이유 중 하나이다.

- 변수는 사용하는 위치에 최대한 가까이 선언한다. 우리가 만든 함수는 매우 짧으므로 지역 변수는 각 함수 맨 처음에 선언한다.

- 반면 인스턴스 변수는 클래스 맨 처음에 선언하고, 변수 간에 세로로 거리를 두지 않는다. 잘 설계한 클래스는 많은 클래스 메서드가 인스턴스 변수를 사용하기 때문이다.

- c++에서는 모든 인스턴스 변수를 클래스 마지막에 선언하는 가위 규칙을 적용하고, 자바는 클래스 맨 처음에 인스턴스 변수를 선언하다. 잘 알려진 위치에 인스턴스 변수를 모은다는 것이 중요하다.

- 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다. 그러면 또한 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다.

- 개념적인 친화도가 높을수록 코드를 가까이 배치한다. 한 함수가 다른 함수를 호출하며 생기는 직접적인 종속성, 변수와 그 변수를 사용하는 함수, 비슷한 동작을 수행하는 일군의 함수가 그 예이다.

- 가로로 짧은 행이 바람직하다. 20~60자가 흔하고, 120자 위로는 행 길이를 제한하는 것이 좋다,

- 가로 공백(띄어쓰기)을 통해 밀접한 개념과 느슨한 개념을 표현한다. 할당 연산자를 강조하기 위해 앞뒤에 공백을 준다. 함수 이름과 이어지는 괄호 사이엔 공백을 넣지 않는다. 함수와 인수는 서로 밀접하기 때문이다. 함수를 호출하는 코드에서 괄호 안 인수는 공백으로 분리한다.

- 연산자 우선순위를 강조하기 위해서도 공백을 사용하지만, 나중에 도구에서 없애는 경우가 흔하다.

- 한 행이라도 들여쓰기로 범위를 제대로 표현하는 것이 좋다.

- 빈 while, for 문이라도 새 행에다 들여쓰기 후에 ;를 제대로 넣어준다.

- 팀은 한 가지 규칙에 합의해야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다. 

# 6. 객체와 자료 구조

- 변수를 비공개(private)로 정의하는 것은 남들이 변수에 의존하지 않게 하기 위해서이다. 이를 통해, 나중에 변수 타입이나 구현을 다른 것에 신경쓰지 않고 맘대로 바꾸고 싶어서이다. 

- 변수를 private으로 선언하더라도 각 값마다 조회(get) 함수와 설정(set) 함수를 제공한다면 구현을 외부로 노출하는 셈이다. 

- 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지 않는다. 구현을 감추려면 추상화가 필요하다. 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스이다.

- 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다. 인터페이스나 get/set 함수만으로는 추상화가 이뤄지지 않는다. 아무 생각 없이 get/set 함수를 추가하는 방법이 가장 나쁘다.

## 객체와 자료구조

- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.

- 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. 보통 다른 클래스에서 자료구조를 사용한 절차적인 코드로 함수를 구현한다.

- 자료구조를 사용하는 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 

- 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다.

## 디미터 법칙

- 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.

- 객체는 자료를 숨기고 함수를 공개한다. 즉 객체는 get함수로 내부 구조를 공개하면 안된다.

- 디미터 법칙에 따르면, 클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다.
1) 클래스 C
2) f가 생성한 객체
3) f 인수로 넘어온 객체
4) C 인스턴스 변수에 저장된 객체

- 하지만 위 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안 된다.

```
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```
- 위와 같은 코드를 기차 충돌이라. 부른다. 피하는 것이 좋다. 또한 객체라면 ctxt.getOptions() 뒤로는 디미터 법칙을 위반한다.

```
final String outputDir = ctxt.options.scratchDir.absolutePath;
```
- 자료구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다.

- 만약 cxtx가 객체라면 속을 드러내라고 하기 보단 뭔가를 하라고 시켜야 하는 쪽으로 구조를 바꿔야 한다.


## 혼란

- 자료구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 비공개 변수화 공개 함수를 포함한다면 문제는 훨씬 간단하리라. 하지만 단순한 자료구조에도 get set 함수 정의를 요구하는 프레임워크와 표준이 존재한다.

- 이런 혼란으로 때때로 절반은 객체, 절반은 자료 구조인 잡종 구조가 나온다. 잡종 구조는 중요한 기능을 수행하는 함수도 있고, 공개변수나 공개 get/set 함수도 있다.

- 잡종 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다. 즉 단점만 모아놓은 구조다. 잡종 구조는 되도록 피하는 것이 좋다.


## 기타 파생 구조

- 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 자료 전달 객체(DTO) 라고 한다.

- 흔히 DTO는 데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 구조체이다.

- 좀 더 일반적인 형태는 '빈'구조다. 빈은 비공개 변수를 get/set 함수로 조작한다. 일종의 사이비 캡슐화로, 일부 순수주의자나 만족시킬 뿐 별다른 이익을 제공하지 않는다. 

- 활성 레코드는 DTO의 특수한 형태로, 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, save와 find 같은 탐색 함수도 제공한다. 하지만 이는 바람직하지 않은 잡종 구조이다.
  
   해결은 활성 레코드를 자료 구조로 취급하고, 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다.
```
//자료구조
public class record{
    pubilc int name;
    pubilc int number;
}
//비즈니스 규칙을 담고 내부 자료를 숨기는 객체
public class recordManager{
    private record;
    public businessFunction();
}
```
    

